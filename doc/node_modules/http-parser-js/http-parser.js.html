<!DOCTYPE html>
<html>
<head>
  <title>http-parser.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/http-parser-js/http-parser.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>http-parser.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-comment">/*jshint node:true */</span>

<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

exports.HTTPParser = HTTPParser;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HTTPParser</span>(<span class="hljs-params">type</span>) </span>{
  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);
  <span class="hljs-keyword">this</span>.type = type;
  <span class="hljs-keyword">this</span>.state = type + <span class="hljs-string">'_LINE'</span>;
  <span class="hljs-keyword">this</span>.info = {
    <span class="hljs-attr">headers</span>: [],
    <span class="hljs-attr">upgrade</span>: <span class="hljs-literal">false</span>
  };
  <span class="hljs-keyword">this</span>.trailers = [];
  <span class="hljs-keyword">this</span>.line = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">this</span>.isChunked = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.connection = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">this</span>.headerSize = <span class="hljs-number">0</span>; <span class="hljs-comment">// for preventing too big headers</span>
  <span class="hljs-keyword">this</span>.body_bytes = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.isUserCall = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.hadError = <span class="hljs-literal">false</span>;
}
HTTPParser.encoding = <span class="hljs-string">'ascii'</span>;
HTTPParser.maxHeaderSize = <span class="hljs-number">80</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// maxHeaderSize (in bytes) is configurable, but 80kb by default;</span>
HTTPParser.REQUEST = <span class="hljs-string">'REQUEST'</span>;
HTTPParser.RESPONSE = <span class="hljs-string">'RESPONSE'</span>;
<span class="hljs-keyword">var</span> kOnHeaders = HTTPParser.kOnHeaders = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> kOnHeadersComplete = HTTPParser.kOnHeadersComplete = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> kOnBody = HTTPParser.kOnBody = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> kOnMessageComplete = HTTPParser.kOnMessageComplete = <span class="hljs-number">3</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Some handler stubs, needed for compatibility</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">HTTPParser.prototype[kOnHeaders] =
HTTPParser.prototype[kOnHeadersComplete] =
HTTPParser.prototype[kOnBody] =
HTTPParser.prototype[kOnMessageComplete] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

<span class="hljs-keyword">var</span> compatMode0_12 = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">Object</span>.defineProperty(HTTPParser, <span class="hljs-string">'kOnExecute'</span>, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>hack for backward compatibility</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      compatMode0_12 = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
    }
  });

<span class="hljs-keyword">var</span> methods = exports.methods = HTTPParser.methods = [
  <span class="hljs-string">'DELETE'</span>,
  <span class="hljs-string">'GET'</span>,
  <span class="hljs-string">'HEAD'</span>,
  <span class="hljs-string">'POST'</span>,
  <span class="hljs-string">'PUT'</span>,
  <span class="hljs-string">'CONNECT'</span>,
  <span class="hljs-string">'OPTIONS'</span>,
  <span class="hljs-string">'TRACE'</span>,
  <span class="hljs-string">'COPY'</span>,
  <span class="hljs-string">'LOCK'</span>,
  <span class="hljs-string">'MKCOL'</span>,
  <span class="hljs-string">'MOVE'</span>,
  <span class="hljs-string">'PROPFIND'</span>,
  <span class="hljs-string">'PROPPATCH'</span>,
  <span class="hljs-string">'SEARCH'</span>,
  <span class="hljs-string">'UNLOCK'</span>,
  <span class="hljs-string">'BIND'</span>,
  <span class="hljs-string">'REBIND'</span>,
  <span class="hljs-string">'UNBIND'</span>,
  <span class="hljs-string">'ACL'</span>,
  <span class="hljs-string">'REPORT'</span>,
  <span class="hljs-string">'MKACTIVITY'</span>,
  <span class="hljs-string">'CHECKOUT'</span>,
  <span class="hljs-string">'MERGE'</span>,
  <span class="hljs-string">'M-SEARCH'</span>,
  <span class="hljs-string">'NOTIFY'</span>,
  <span class="hljs-string">'SUBSCRIBE'</span>,
  <span class="hljs-string">'UNSUBSCRIBE'</span>,
  <span class="hljs-string">'PATCH'</span>,
  <span class="hljs-string">'PURGE'</span>,
  <span class="hljs-string">'MKCALENDAR'</span>,
  <span class="hljs-string">'LINK'</span>,
  <span class="hljs-string">'UNLINK'</span>
];
<span class="hljs-keyword">var</span> method_connect = methods.indexOf(<span class="hljs-string">'CONNECT'</span>);
HTTPParser.prototype.reinitialize = HTTPParser;
HTTPParser.prototype.close =
HTTPParser.prototype.pause =
HTTPParser.prototype.resume =
HTTPParser.prototype.free = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
HTTPParser.prototype._compatMode0_11 = <span class="hljs-literal">false</span>;
HTTPParser.prototype.getAsyncId = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; };

<span class="hljs-keyword">var</span> headerState = {
  <span class="hljs-attr">REQUEST_LINE</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">RESPONSE_LINE</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">HEADER</span>: <span class="hljs-literal">true</span>
};
HTTPParser.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk, start, length</span>) </span>{
  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> HTTPParser)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'not a HTTPParser'</span>);
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>backward compat to node &lt; 0.11.4
Note: the start and length params were removed in newer version</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  start = start || <span class="hljs-number">0</span>;
  length = <span class="hljs-keyword">typeof</span> length === <span class="hljs-string">'number'</span> ? length : chunk.length;

  <span class="hljs-keyword">this</span>.chunk = chunk;
  <span class="hljs-keyword">this</span>.offset = start;
  <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.end = start + length;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.offset &lt; end) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.state]()) {
        <span class="hljs-keyword">break</span>;
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isUserCall) {
      <span class="hljs-keyword">throw</span> err;
    }
    <span class="hljs-keyword">this</span>.hadError = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> err;
  }
  <span class="hljs-keyword">this</span>.chunk = <span class="hljs-literal">null</span>;
  length = <span class="hljs-keyword">this</span>.offset - start;
  <span class="hljs-keyword">if</span> (headerState[<span class="hljs-keyword">this</span>.state]) {
    <span class="hljs-keyword">this</span>.headerSize += length;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.headerSize &gt; HTTPParser.maxHeaderSize) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'max header size exceeded'</span>);
    }
  }
  <span class="hljs-keyword">return</span> length;
};

<span class="hljs-keyword">var</span> stateFinishAllowed = {
  <span class="hljs-attr">REQUEST_LINE</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">RESPONSE_LINE</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">BODY_RAW</span>: <span class="hljs-literal">true</span>
};
HTTPParser.prototype.finish = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hadError) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (!stateFinishAllowed[<span class="hljs-keyword">this</span>.state]) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid state for EOF'</span>);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'BODY_RAW'</span>) {
    <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnMessageComplete]());
  }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>These three methods are used for an internal speed optimization, and it also
works if theses are noops. Basically consume() asks us to read the bytes
ourselves, but if we don't do it we get them through execute().</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">HTTPParser.prototype.consume =
HTTPParser.prototype.unconsume =
HTTPParser.prototype.getCurrentBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>For correct error handling - see HTTPParser#execute
Usage: this.userCall()(userFunction('arg'));</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">HTTPParser.prototype.userCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.isUserCall = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ret</span>) </span>{
    self.isUserCall = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> ret;
  };
};

HTTPParser.prototype.nextRequest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnMessageComplete]());
  <span class="hljs-keyword">this</span>.reinitialize(<span class="hljs-keyword">this</span>.type);
};

HTTPParser.prototype.consumeLine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.end,
      chunk = <span class="hljs-keyword">this</span>.chunk;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-keyword">this</span>.offset; i &lt; end; i++) {
    <span class="hljs-keyword">if</span> (chunk[i] === <span class="hljs-number">0x0a</span>) { <span class="hljs-comment">// \n</span>
      <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.line + chunk.toString(HTTPParser.encoding, <span class="hljs-keyword">this</span>.offset, i);
      <span class="hljs-keyword">if</span> (line.charAt(line.length - <span class="hljs-number">1</span>) === <span class="hljs-string">'\r'</span>) {
        line = line.substr(<span class="hljs-number">0</span>, line.length - <span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">this</span>.line = <span class="hljs-string">''</span>;
      <span class="hljs-keyword">this</span>.offset = i + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> line;
    }
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>line split over multiple chunks</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">this</span>.line += chunk.toString(HTTPParser.encoding, <span class="hljs-keyword">this</span>.offset, <span class="hljs-keyword">this</span>.end);
  <span class="hljs-keyword">this</span>.offset = <span class="hljs-keyword">this</span>.end;
};

<span class="hljs-keyword">var</span> headerExp = <span class="hljs-regexp">/^([^: \t]+):[ \t]*((?:.*[^ \t])|)/</span>;
<span class="hljs-keyword">var</span> headerContinueExp = <span class="hljs-regexp">/^[ \t]+(.*[^ \t])/</span>;
HTTPParser.prototype.parseHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line, headers</span>) </span>{
  <span class="hljs-keyword">if</span> (line.indexOf(<span class="hljs-string">'\r'</span>) !== <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">throw</span> parseErrorCode(<span class="hljs-string">'HPE_LF_EXPECTED'</span>);
  }

  <span class="hljs-keyword">var</span> match = headerExp.exec(line);
  <span class="hljs-keyword">var</span> k = match &amp;&amp; match[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">if</span> (k) { <span class="hljs-comment">// skip empty string (malformed header)</span>
    headers.push(k);
    headers.push(match[<span class="hljs-number">2</span>]);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> matchContinue = headerContinueExp.exec(line);
    <span class="hljs-keyword">if</span> (matchContinue &amp;&amp; headers.length) {
      <span class="hljs-keyword">if</span> (headers[headers.length - <span class="hljs-number">1</span>]) {
        headers[headers.length - <span class="hljs-number">1</span>] += <span class="hljs-string">' '</span>;
      }
      headers[headers.length - <span class="hljs-number">1</span>] += matchContinue[<span class="hljs-number">1</span>];
    }
  }
};

<span class="hljs-keyword">var</span> requestExp = <span class="hljs-regexp">/^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/</span>;
HTTPParser.prototype.REQUEST_LINE = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.consumeLine();
  <span class="hljs-keyword">if</span> (!line) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">var</span> match = requestExp.exec(line);
  <span class="hljs-keyword">if</span> (match === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> parseErrorCode(<span class="hljs-string">'HPE_INVALID_CONSTANT'</span>);
  }
  <span class="hljs-keyword">this</span>.info.method = <span class="hljs-keyword">this</span>._compatMode0_11 ? match[<span class="hljs-number">1</span>] : methods.indexOf(match[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.info.method === <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid request method'</span>);
  }
  <span class="hljs-keyword">this</span>.info.url = match[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">this</span>.info.versionMajor = +match[<span class="hljs-number">3</span>];
  <span class="hljs-keyword">this</span>.info.versionMinor = +match[<span class="hljs-number">4</span>];
  <span class="hljs-keyword">this</span>.body_bytes = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'HEADER'</span>;
};

<span class="hljs-keyword">var</span> responseExp = <span class="hljs-regexp">/^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/</span>;
HTTPParser.prototype.RESPONSE_LINE = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.consumeLine();
  <span class="hljs-keyword">if</span> (!line) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">var</span> match = responseExp.exec(line);
  <span class="hljs-keyword">if</span> (match === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> parseErrorCode(<span class="hljs-string">'HPE_INVALID_CONSTANT'</span>);
  }
  <span class="hljs-keyword">this</span>.info.versionMajor = +match[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">this</span>.info.versionMinor = +match[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">var</span> statusCode = <span class="hljs-keyword">this</span>.info.statusCode = +match[<span class="hljs-number">3</span>];
  <span class="hljs-keyword">this</span>.info.statusMessage = match[<span class="hljs-number">4</span>];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Implied zero length.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> ((statusCode / <span class="hljs-number">100</span> | <span class="hljs-number">0</span>) === <span class="hljs-number">1</span> || statusCode === <span class="hljs-number">204</span> || statusCode === <span class="hljs-number">304</span>) {
    <span class="hljs-keyword">this</span>.body_bytes = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'HEADER'</span>;
};

HTTPParser.prototype.shouldKeepAlive = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.info.versionMajor &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.info.versionMinor &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection.indexOf(<span class="hljs-string">'close'</span>) !== <span class="hljs-number">-1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection.indexOf(<span class="hljs-string">'keep-alive'</span>) === <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.body_bytes !== <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>.isChunked) { <span class="hljs-comment">// || skipBody</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

HTTPParser.prototype.HEADER = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.consumeLine();
  <span class="hljs-keyword">if</span> (line === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">var</span> info = <span class="hljs-keyword">this</span>.info;
  <span class="hljs-keyword">if</span> (line) {
    <span class="hljs-keyword">this</span>.parseHeader(line, info.headers);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> headers = info.headers;
    <span class="hljs-keyword">var</span> hasContentLength = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> currentContentLengthValue;
    <span class="hljs-keyword">var</span> hasUpgradeHeader = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; headers.length; i += <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">switch</span> (headers[i].toLowerCase()) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'transfer-encoding'</span>:
          <span class="hljs-keyword">this</span>.isChunked = headers[i + <span class="hljs-number">1</span>].toLowerCase() === <span class="hljs-string">'chunked'</span>;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'content-length'</span>:
          currentContentLengthValue = +headers[i + <span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (hasContentLength) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Fix duplicate Content-Length header with same values.
Throw error only if values are different.
Known issues:
https://github.com/request/request/issues/2091#issuecomment-328715113
https://github.com/nodejs/node/issues/6517#issuecomment-216263771</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (currentContentLengthValue !== <span class="hljs-keyword">this</span>.body_bytes) {
              <span class="hljs-keyword">throw</span> parseErrorCode(<span class="hljs-string">'HPE_UNEXPECTED_CONTENT_LENGTH'</span>);
            }
          } <span class="hljs-keyword">else</span> {
            hasContentLength = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">this</span>.body_bytes = currentContentLengthValue;
          }
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'connection'</span>:
          <span class="hljs-keyword">this</span>.connection += headers[i + <span class="hljs-number">1</span>].toLowerCase();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'upgrade'</span>:
          hasUpgradeHeader = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">break</span>;
      }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>See https://github.com/creationix/http-parser-js/pull/53
if both isChunked and hasContentLength, content length wins
because it has been verified to match the body length already</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isChunked &amp;&amp; hasContentLength) {
      <span class="hljs-keyword">this</span>.isChunked = <span class="hljs-literal">false</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737
&quot;For responses, &quot;Upgrade: foo&quot; and &quot;Connection: upgrade&quot; are
mandatory only when it is a 101 Switching Protocols response,
otherwise it is purely informational, to announce support.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (hasUpgradeHeader &amp;&amp; <span class="hljs-keyword">this</span>.connection.indexOf(<span class="hljs-string">'upgrade'</span>) != <span class="hljs-number">-1</span>) {
      info.upgrade = <span class="hljs-keyword">this</span>.type === HTTPParser.REQUEST || info.statusCode === <span class="hljs-number">101</span>;
    } <span class="hljs-keyword">else</span> {
      info.upgrade = info.method === method_connect;
    }

    info.shouldKeepAlive = <span class="hljs-keyword">this</span>.shouldKeepAlive();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>problem which also exists in original node: we should know skipBody before calling onHeadersComplete</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> skipBody;
    <span class="hljs-keyword">if</span> (compatMode0_12) {
      skipBody = <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnHeadersComplete](info));
    } <span class="hljs-keyword">else</span> {
      skipBody = <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnHeadersComplete](info.versionMajor,
          info.versionMinor, info.headers, info.method, info.url, info.statusCode,
          info.statusMessage, info.upgrade, info.shouldKeepAlive));
    }
    <span class="hljs-keyword">if</span> (skipBody === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">this</span>.nextRequest();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isChunked &amp;&amp; !skipBody) {
      <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_CHUNKHEAD'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipBody || <span class="hljs-keyword">this</span>.body_bytes === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.nextRequest();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,
need this &quot;return true;&quot; if it's an upgrade request.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> info.upgrade;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.body_bytes === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_RAW'</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_SIZED'</span>;
    }
  }
};

HTTPParser.prototype.BODY_CHUNKHEAD = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.consumeLine();
  <span class="hljs-keyword">if</span> (line === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">this</span>.body_bytes = <span class="hljs-built_in">parseInt</span>(line, <span class="hljs-number">16</span>);
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.body_bytes) {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_CHUNKTRAILERS'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_CHUNK'</span>;
  }
};

HTTPParser.prototype.BODY_CHUNK = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> length = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.end - <span class="hljs-keyword">this</span>.offset, <span class="hljs-keyword">this</span>.body_bytes);
  <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnBody](<span class="hljs-keyword">this</span>.chunk, <span class="hljs-keyword">this</span>.offset, length));
  <span class="hljs-keyword">this</span>.offset += length;
  <span class="hljs-keyword">this</span>.body_bytes -= length;
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.body_bytes) {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_CHUNKEMPTYLINE'</span>;
  }
};

HTTPParser.prototype.BODY_CHUNKEMPTYLINE = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.consumeLine();
  <span class="hljs-keyword">if</span> (line === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span>;
  }
  assert.equal(line, <span class="hljs-string">''</span>);
  <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'BODY_CHUNKHEAD'</span>;
};

HTTPParser.prototype.BODY_CHUNKTRAILERS = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.consumeLine();
  <span class="hljs-keyword">if</span> (line === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (line) {
    <span class="hljs-keyword">this</span>.parseHeader(line, <span class="hljs-keyword">this</span>.trailers);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.trailers.length) {
      <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnHeaders](<span class="hljs-keyword">this</span>.trailers, <span class="hljs-string">''</span>));
    }
    <span class="hljs-keyword">this</span>.nextRequest();
  }
};

HTTPParser.prototype.BODY_RAW = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>.end - <span class="hljs-keyword">this</span>.offset;
  <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnBody](<span class="hljs-keyword">this</span>.chunk, <span class="hljs-keyword">this</span>.offset, length));
  <span class="hljs-keyword">this</span>.offset = <span class="hljs-keyword">this</span>.end;
};

HTTPParser.prototype.BODY_SIZED = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> length = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.end - <span class="hljs-keyword">this</span>.offset, <span class="hljs-keyword">this</span>.body_bytes);
  <span class="hljs-keyword">this</span>.userCall()(<span class="hljs-keyword">this</span>[kOnBody](<span class="hljs-keyword">this</span>.chunk, <span class="hljs-keyword">this</span>.offset, length));
  <span class="hljs-keyword">this</span>.offset += length;
  <span class="hljs-keyword">this</span>.body_bytes -= length;
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.body_bytes) {
    <span class="hljs-keyword">this</span>.nextRequest();
  }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>backward compat to node &lt; 0.11.6</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">[<span class="hljs-string">'Headers'</span>, <span class="hljs-string">'HeadersComplete'</span>, <span class="hljs-string">'Body'</span>, <span class="hljs-string">'MessageComplete'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">var</span> k = HTTPParser[<span class="hljs-string">'kOn'</span> + name];
  <span class="hljs-built_in">Object</span>.defineProperty(HTTPParser.prototype, <span class="hljs-string">'on'</span> + name, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[k];
    },
    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>hack for backward compatibility</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">this</span>._compatMode0_11 = <span class="hljs-literal">true</span>;
      method_connect = <span class="hljs-string">'CONNECT'</span>;
      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>[k] = to);
    }
  });
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseErrorCode</span>(<span class="hljs-params">code</span>) </span>{
  <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Parse Error'</span>);
  err.code = code;
  <span class="hljs-keyword">return</span> err;
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
